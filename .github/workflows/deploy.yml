name: Build and Deploy BOI4I

on:
  push:
    branches:
      - release/test
      - release/prelive

env:
  DOTNET_VERSION: '8.0.x'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: Build and Publish
      run: |
        dotnet restore
        dotnet build --configuration Release
        dotnet test --configuration Release
        dotnet publish BOI.Web/BOI.Web.csproj \
          --configuration Release \
          --output ./publish
          
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: boi4i-app-${{ github.ref_name == 'release/test' && 'release-test' || github.ref_name == 'release/prelive' && 'release-prelive' || github.ref_name }}
        path: ./publish/

  deploy:
    needs: build
    runs-on: [self-hosted, windows]
    environment: ${{ github.ref_name }}
    env:
      ENV_SUFFIX: ${{ github.ref_name == 'release/test' && 'BOI4I_TEST' || github.ref_name == 'release/prelive' && 'BOI4I_PRELIVE' || 'BOI4I_PROD' }}
    
    steps:
    - name: Download artifact
      uses: actions/download-artifact@v4
      with:
        name: boi4i-app-${{ github.ref_name == 'release/test' && 'release-test' || github.ref_name == 'release/prelive' && 'release-prelive' || github.ref_name }}
        path: ./publish/

    - name: Debug environment
      run: |
        echo "Branch: ${{ github.ref_name }}"
        echo "Environment Suffix: ${{ env.ENV_SUFFIX }}"
        echo "Expected secrets:"
        echo "  DEPLOY_HOST_${{ env.ENV_SUFFIX }}"
        echo "  DEPLOY_USER_${{ env.ENV_SUFFIX }}"
        echo "  DEPLOY_PASSWORD_${{ env.ENV_SUFFIX }}"
        echo "  DEPLOY_PATH_${{ env.ENV_SUFFIX }}"
        echo "  APP_POOL_${{ env.ENV_SUFFIX }}"
        
        # Validate required secrets are set
        $deployPath = "${{ secrets[format('DEPLOY_PATH_{0}', env.ENV_SUFFIX)] }}"
        $appPool = "${{ secrets[format('APP_POOL_{0}', env.ENV_SUFFIX)] }}"
        
        echo "Actual values:"
        echo "  Deploy Path: '$deployPath'"
        echo "  App Pool: '$appPool'"
        
        if ([string]::IsNullOrWhiteSpace($deployPath)) {
          Write-Error "DEPLOY_PATH_${{ env.ENV_SUFFIX }} secret is not set or is empty"
          exit 1
        }
        
        if ([string]::IsNullOrWhiteSpace($appPool)) {
          Write-Error "APP_POOL_${{ env.ENV_SUFFIX }} secret is not set or is empty"
          exit 1
        }

    - name: Create deployment package
      run: |
        Compress-Archive -Path "./publish/*" -DestinationPath "./deployment-package.zip" -Force

    - name: Deploy application
      run: |
        
        try {

          # Import IIS module
          Import-Module WebAdministration -ErrorAction Stop

          # Copy the deployment package to the remote server
          Copy-Item -Path "./deployment-package.zip" -Destination "C:\Temp\deployment-package.zip" 
          
          # Execute deployment script on remote server
          Write-Host "Executing deployment on remote server..."
          Invoke-Command -ScriptBlock {
            param($DeployPath, $AppPool, $RefName)
            
            # Import required modules with error handling
            Write-Host "Importing WebAdministration module..."
            try {
              Import-Module WebAdministration -ErrorAction Stop
              Write-Host "WebAdministration module imported successfully"
            } catch {
              Write-Host "Error importing WebAdministration module: $($_.Exception.Message)"
              Write-Host "Checking if IIS Management Tools are installed..."
              
              # Check if IIS Management Console is available
              $iisModulePath = "${env:ProgramFiles}\IIS\PowerShell\Snapin\Microsoft.IIS.PowerShell.Provider.dll"
              if (Test-Path $iisModulePath) {
                Write-Host "Found IIS PowerShell provider at: $iisModulePath"
                try {
                  Import-Module $iisModulePath -ErrorAction Stop
                  Write-Host "IIS PowerShell provider imported successfully"
                } catch {
                  Write-Host "Failed to import IIS PowerShell provider: $($_.Exception.Message)"
                  throw "IIS Management Tools are not properly installed or configured"
                }
              } else {
                Write-Host "IIS Management Tools not found. Checking alternative paths..."
                
                # Try alternative import methods
                try {
                  Add-PSSnapin WebAdministration -ErrorAction Stop
                  Write-Host "WebAdministration snapin added successfully"
                } catch {
                  Write-Host "Failed to add WebAdministration snapin: $($_.Exception.Message)"
                  throw "IIS Management Tools are not installed. Please install IIS Management Console."
                }
              }
            }
            
            # Verify WebAdministration commands are available
            Write-Host "Verifying WebAdministration commands are available..."
            try {
              $testCommand = Get-Command Get-WebAppPool -ErrorAction Stop
              Write-Host "WebAdministration commands verified successfully"
            } catch {
              Write-Host "Error: WebAdministration commands are not available: $($_.Exception.Message)"
              throw "WebAdministration module is not properly loaded. Cannot proceed with IIS operations."
            }
            
            # Enable long path support for this PowerShell session
            try {
              $registryPath = "HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem"
              $longPathEnabled = Get-ItemProperty -Path $registryPath -Name "LongPathsEnabled" -ErrorAction SilentlyContinue
              if ($longPathEnabled -and $longPathEnabled.LongPathsEnabled -eq 1) {
                Write-Host "Long path support is already enabled"
              } else {
                Write-Host "Long path support is not enabled - this may cause issues with very long filenames"
              }
            } catch {
              Write-Host "Could not check long path support status: $($_.Exception.Message)"
            }
            
            # Validate application pool exists before trying to stop it
            Write-Host "Checking if application pool exists: $AppPool"
            $appPoolExists = Get-WebAppPool -Name $AppPool -ErrorAction SilentlyContinue
            if (-not $appPoolExists) {
              Write-Host "Warning: Application pool '$AppPool' does not exist. Skipping application pool operations."
            } else {
              # Stop the application pool
              Write-Host "Stopping application pool: $AppPool"
              try {
                Stop-WebAppPool -Name $AppPool -ErrorAction Stop
                Write-Host "Application pool stopped successfully"
              } catch {
                if ($_.Exception.Message -like "*already stopped*") {
                  Write-Host "Application pool is already stopped"
                } else {
                  Write-Host "Warning: Could not stop application pool: $($_.Exception.Message)"
                }
              }
            }
            
            # Stop the website
            Write-Host "Stopping website..."
            try {
              $siteName = (Get-WebAppPoolState -Name $AppPool).ApplicationPool
              $sites = Get-Website | Where-Object { $_.ApplicationPool -eq $AppPool }
              foreach ($site in $sites) {
                Write-Host "Stopping website: $($site.Name)"
                Stop-Website -Name $site.Name -ErrorAction Stop
                Write-Host "Website '$($site.Name)' stopped successfully"
              }
            } catch {
              Write-Host "Warning: Could not stop website: $($_.Exception.Message)"
            }
            
            # Wait for application to fully stop
            Write-Host "Waiting 5 seconds for application to fully stop..."
            Start-Sleep -Seconds 5
            
            # Create backup only for prelive environment
            if (Test-Path $DeployPath) {
              if ($RefName -like "*prelive*") {
                $backupPath = "C:\Backups\$RefName-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
                Write-Host "Creating backup at: $backupPath"
                New-Item -ItemType Directory -Path "C:\Backups" -Force | Out-Null
                Copy-Item -Path $DeployPath -Destination $backupPath -Recurse -Force
              } else {
                Write-Host "Skipping backup for test environment"
              }
              
              # Remove existing files with error handling for long paths
              Write-Host "Removing existing files from deployment path..."
              try {
                Get-ChildItem -Path $DeployPath -Recurse | Remove-Item -Force -Recurse
                Write-Host "Successfully removed existing files"
              } catch {
                Write-Host "Standard removal failed, trying robocopy method for long paths..."
                try {
                  # Use robocopy to handle long paths - create empty dir and mirror it to target
                  $emptyDir = "C:\Temp\empty_$(Get-Random)"
                  New-Item -ItemType Directory -Path $emptyDir -Force | Out-Null
                  robocopy $emptyDir $DeployPath /MIR /NFL /NDL /NJH /NJS /NC /NS /NP
                  Remove-Item $emptyDir -Force -Recurse
                  Write-Host "Successfully removed files using robocopy"
                } catch {
                  Write-Host "Warning: Could not remove all files: $($_.Exception.Message)"
                  Write-Host "Continuing with deployment..."
                }
              }
            } else {
              Write-Host "Creating deployment directory: $DeployPath"
              New-Item -ItemType Directory -Path $DeployPath -Force | Out-Null
            }
            
            # Extract deployment package
            Write-Host "Extracting deployment package..."
            Expand-Archive -Path "C:\Temp\deployment-package.zip" -DestinationPath $DeployPath -Force
            Remove-Item "C:\Temp\deployment-package.zip" -Force
            
            # Update web.config with environment-specific settings based on branch
            $webConfigPath = Join-Path $DeployPath "web.config"
            if (Test-Path $webConfigPath) {
              Write-Host "Updating web.config environment settings for branch: $RefName"
              
              # Determine environment based on branch name
              $environment = switch ($RefName.ToLower()) {
                { $_ -like "*test*" } { "Test" }
                { $_ -like "*prelive*" } { "Prelive" }
              }
              
              Write-Host "Setting ASPNETCORE_ENVIRONMENT to: $environment"
              
              # Load and update web.config
              [xml]$webConfig = Get-Content $webConfigPath
              
              # Debug: Show XML structure
              Write-Host "Debug: XML loaded successfully"
              Write-Host "Debug: Configuration exists: $($webConfig.configuration -ne $null)"
              Write-Host "Debug: Location exists: $($webConfig.configuration.location -ne $null)"
              Write-Host "Debug: system.webServer exists: $($webConfig.configuration.location.'system.webServer' -ne $null)"
              Write-Host "Debug: aspNetCore exists: $($webConfig.configuration.location.'system.webServer'.aspNetCore -ne $null)"
              Write-Host "Debug: environmentVariables exists: $($webConfig.configuration.location.'system.webServer'.aspNetCore.environmentVariables -ne $null)"
              
              $environmentVariables = $webConfig.configuration.location.'system.webServer'.aspNetCore.environmentVariables.environmentVariable
              Write-Host "Debug: Environment variables count: $($environmentVariables.Count)"
              
              if ($environmentVariables) {
                Write-Host "Debug: Available environment variables:"
                foreach ($envVar in $environmentVariables) {
                  Write-Host "  - Name: '$($envVar.name)', Value: '$($envVar.value)'"
                }
              }
              
              $targetVariable = $environmentVariables | Where-Object { $_.name -eq "ASPNETCORE_ENVIRONMENT" }
              
              Write-Host "Target variable found: $($targetVariable -ne $null)"
              if ($targetVariable) {
                Write-Host "Target variable name: $($targetVariable.name)"
                Write-Host "Target variable current value: $($targetVariable.value)"
              }
              
              if ($targetVariable) {
                $oldValue = $targetVariable.value
                $targetVariable.value = $environment
                $webConfig.Save($webConfigPath)
                Write-Host "Updated ASPNETCORE_ENVIRONMENT from '$oldValue' to '$environment'"
              } else {
                Write-Host "Warning: ASPNETCORE_ENVIRONMENT variable not found in web.config"
              }
            } else {
              Write-Host "Warning: web.config not found at $webConfigPath"
            }
            
            # Start the application pool
            Write-Host "Starting application pool: $AppPool"
            try {
              Start-WebAppPool -Name $AppPool -ErrorAction Stop
              Write-Host "Application pool started successfully"
            } catch {
              Write-Host "Error starting application pool: $($_.Exception.Message)"
              throw
            }
            
            # Start the website
            Write-Host "Starting website..."
            try {
              $sites = Get-Website | Where-Object { $_.ApplicationPool -eq $AppPool }
              foreach ($site in $sites) {
                Write-Host "Starting website: $($site.Name)"
                Start-Website -Name $site.Name -ErrorAction Stop
                Write-Host "Website '$($site.Name)' started successfully"
              }
            } catch {
              Write-Host "Warning: Could not start website: $($_.Exception.Message)"
            }
            
            # Wait for application to start
            Write-Host "Waiting for application to start..."
            Start-Sleep -Seconds 15
            
            # Verify deployment
            Write-Host "Deployment completed successfully!"
          } -ArgumentList "${{ secrets[format('DEPLOY_PATH_{0}', env.ENV_SUFFIX)] }}", "${{ secrets[format('APP_POOL_{0}', env.ENV_SUFFIX)] }}", "${{ github.ref_name }}"
          
        } finally {
        }